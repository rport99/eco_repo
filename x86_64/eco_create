#!/usr/bin/env bash
# Intelligent & Robust Repository Management Script for Arch/Pacman Repo
# Version: 2.5 â€” Fixes pacman sync issues by ensuring:
#   âœ… consistent repo naming (default: eco-repo)
#   âœ… creates pacman-expected names: repo.db + repo.files (symlink or copy)
#   âœ… supports GitLab Pages style publishing (optional: PUBLISH_DIR=public)
#
# Typical usage:
#   REPO_NAME="eco-repo" DB_ARCHIVE_EXT="tar.gz" ./repo_update.sh "Update repo"
#
# If using GitLab Pages:
#   PUBLISH_DIR="public" ./repo_update.sh
# and your CI should publish the public/ directory.

set -euo pipefail

# === COLORS ===
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

print_msg(){ local c="${2:-$NC}"; echo -e "${c}${1}${NC}"; }
die(){ print_msg "âœ— Fatal: $1" "$RED" >&2; exit 1; }
warn(){ print_msg "âš  Warning: $1" "$YELLOW"; }
success(){ print_msg "âœ“ $1" "$GREEN"; }
info(){ print_msg "â„¹ $1" "$BLUE"; }

# === CONFIG ===
# IMPORTANT: pacman repos are most commonly named with hyphens, not underscores.
# Default changed to eco-repo to match typical pacman config/server paths.
REPO_NAME="${REPO_NAME:-eco-repo}"

# tar.gz or tar.zst etc. Keep this aligned with how you host it.
DB_ARCHIVE_EXT="${DB_ARCHIVE_EXT:-tar.gz}"

DB_ARCHIVE="${REPO_NAME}.db.${DB_ARCHIVE_EXT}"
FILES_ARCHIVE="${REPO_NAME}.files.${DB_ARCHIVE_EXT}"

# pacman expects these "bare" names to exist:
DB_BARE="${REPO_NAME}.db"
FILES_BARE="${REPO_NAME}.files"

# If you want to FORCE clean rebuild each run, set:
#   REPO_FORCE_REBUILD=1
REPO_FORCE_REBUILD="${REPO_FORCE_REBUILD:-0}"

# Optional: publish/copy repo output into a directory (useful for GitLab Pages: public/)
# Example: PUBLISH_DIR=public
PUBLISH_DIR="${PUBLISH_DIR:-}"

# Optional: show a suggested pacman.conf stanza (purely informational)
# Example: REPO_SERVER_BASE="https://rport99.gitlab.io/eco-repo"
REPO_SERVER_BASE="${REPO_SERVER_BASE:-}"

require_cmd(){ command -v "$1" >/dev/null 2>&1 || die "'$1' is required but not installed."; }

# Detect whether the configured git remote is GitHub or GitLab (or other)
detect_remote_service() {
  local url host
  url="$(git remote get-url origin 2>/dev/null || true)"
  [[ -n "$url" ]] || { warn "No 'origin' remote configured (no push destination)."; return 0; }

  # Extract host from https://host/... or git@host:...
  if [[ "$url" =~ ^https?://([^/]+)/ ]]; then
    host="${BASH_REMATCH[1]}"
  elif [[ "$url" =~ ^git@([^:]+): ]]; then
    host="${BASH_REMATCH[1]}"
  else
    host="(unknown)"
  fi

  case "${host,,}" in
    *github.com*|*github.*) info "Remote detected: GitHub ($host)";;
    *gitlab.com*|*gitlab.*) info "Remote detected: GitLab ($host)";;
    *) info "Remote detected: $host (unknown provider)";;
  esac

  info "Origin URL: $url"
}

find_pkg_files() {
  find . -maxdepth 1 -type f \( \
    -name "*.pkg.tar.zst" -o \
    -name "*.pkg.tar.xz"  -o \
    -name "*.pkg.tar.gz"  -o \
    -name "*.pkg.tar.bz2" \) -print 2>/dev/null
}

# Extract pkgname from .PKGINFO inside the package
pkg_name_from_file() {
  local pkg="$1"
  tar -xOf "$pkg" .PKGINFO 2>/dev/null | awk -F' = ' '$1=="pkgname"{print $2; exit}' | xargs
}

validate_pkgfile() {
  local pkg="$1"
  [[ -f "$pkg" ]] || { warn "Package file not found: $pkg"; return 1; }
  tar -tf "$pkg" .PKGINFO >/dev/null 2>&1 || { warn "Invalid package (missing .PKGINFO): $pkg"; return 1; }
  local name; name="$(pkg_name_from_file "$pkg" || true)"
  [[ -n "$name" ]] || { warn "Could not extract pkgname from: $pkg"; return 1; }
  success "Validated package: $name ($(basename "$pkg"))"
  return 0
}

# List package names currently present in the repo DB archive
db_list_pkg_names() {
  local dbfile="$1"
  [[ -f "$dbfile" ]] || return 0
  # top-level dirs look like: pkgname-version/
  tar -tf "$dbfile" 2>/dev/null \
    | awk -F/ 'NF>=2 {print $1}' \
    | sed -E 's/-[^-]+-[^-]+$//' \
    | sort -u
}

# Clean DB/files (any compression)
clean_db_files() {
  rm -f "${REPO_NAME}.db" "${REPO_NAME}.files" \
        "${REPO_NAME}.db.tar."* "${REPO_NAME}.files.tar."* \
        "${REPO_NAME}.db."* "${REPO_NAME}.files."* 2>/dev/null || true
}

# Create pacman-friendly names:
#   repo.db      -> repo.db.tar.*
#   repo.files   -> repo.files.tar.*
# Prefer symlinks, but fall back to copying if symlinks arenâ€™t possible.
ensure_pacman_bare_names() {
  local ok=1
  [[ -f "$DB_ARCHIVE" ]] || { warn "DB archive missing: $DB_ARCHIVE"; ok=0; }
  [[ -f "$FILES_ARCHIVE" ]] || { warn "FILES archive missing: $FILES_ARCHIVE"; ok=0; }
  [[ "$ok" == "1" ]] || return 0

  # Remove existing to avoid weirdness
  rm -f "$DB_BARE" "$FILES_BARE" 2>/dev/null || true

  # Try symlink first
  if ln -s "$DB_ARCHIVE" "$DB_BARE" 2>/dev/null && ln -s "$FILES_ARCHIVE" "$FILES_BARE" 2>/dev/null; then
    success "Created symlinks: $DB_BARE -> $DB_ARCHIVE, $FILES_BARE -> $FILES_ARCHIVE"
    return 0
  fi

  # Fallback: copy if symlink fails
  rm -f "$DB_BARE" "$FILES_BARE" 2>/dev/null || true
  cp -f "$DB_ARCHIVE" "$DB_BARE"
  cp -f "$FILES_ARCHIVE" "$FILES_BARE"
  success "Symlink not available; copied: $DB_BARE and $FILES_BARE"
}

# Optional publishing: copy everything to PUBLISH_DIR (dereferencing symlinks)
publish_to_dir() {
  local dir="$1"
  [[ -n "$dir" ]] || return 0
  mkdir -p "$dir"

  info "ðŸ“¤ Publishing repo outputs to: $dir"

  # Copy DB/files (both bare + archives), deref symlinks so Pages serves real files.
  for f in "$DB_ARCHIVE" "$FILES_ARCHIVE" "$DB_BARE" "$FILES_BARE"; do
    if [[ -e "$f" ]]; then
      cp -Lf "$f" "$dir/" || die "Failed to copy $f -> $dir/"
    else
      warn "Publish skip (missing): $f"
    fi
  done

  # Copy packages
  mapfile -t pkgs < <(find_pkg_files)
  if [[ ${#pkgs[@]} -gt 0 ]]; then
    cp -Lf "${pkgs[@]}" "$dir/" || die "Failed to copy packages -> $dir/"
    success "Published ${#pkgs[@]} package(s) to $dir"
  else
    warn "No packages found to publish."
  fi
}

print_pacman_hint() {
  [[ -n "$REPO_SERVER_BASE" ]] || return 0
  print_msg "\nðŸ§© Suggested pacman repo stanza" "$CYAN"
  print_msg "[${REPO_NAME}]"
  print_msg "SigLevel = Optional TrustAll"
  print_msg "Server = ${REPO_SERVER_BASE}/\$arch"
  print_msg "  (Make sure ${REPO_SERVER_BASE} actually contains ${REPO_NAME}.db and packages)"
}

main() {
  info "ðŸš€ Starting ${REPO_NAME} update (v2.5)..."

  require_cmd repo-add
  require_cmd repo-remove
  require_cmd git
  require_cmd tar
  require_cmd awk
  require_cmd sed
  require_cmd find

  # Sanity warning: underscores often cause mismatches with hosted paths/config
  if [[ "$REPO_NAME" == *"_"* ]]; then
    warn "REPO_NAME contains '_' (underscore). If your pacman config/URL uses '-', you will get sync errors."
    warn "Consider: REPO_NAME='${REPO_NAME//_/-}'"
  fi

  detect_remote_service
  print_pacman_hint

  # Collect and validate package files
  mapfile -t all_files < <(find_pkg_files)
  local valid_pkgs=()
  local valid_names=()

  for pkg in "${all_files[@]}"; do
    if validate_pkgfile "$pkg"; then
      valid_pkgs+=("$pkg")
      valid_names+=("$(pkg_name_from_file "$pkg")")
    fi
  done

  if [[ ${#valid_pkgs[@]} -eq 0 ]]; then
    warn "No valid package files found."
  else
    info "Found ${#valid_pkgs[@]} valid package(s)."
  fi

  # Force rebuild option
  if [[ "$REPO_FORCE_REBUILD" == "1" ]]; then
    info "ðŸ§¼ Force rebuild enabled: removing old DB/files..."
    clean_db_files
  fi

  # If DB exists, prune stale entries (things listed in DB but missing from folder)
  if [[ -f "$DB_ARCHIVE" ]] && [[ ${#valid_names[@]} -gt 0 ]]; then
    info "ðŸ§¹ Checking for stale packages in DB..."
    mapfile -t db_names < <(db_list_pkg_names "$DB_ARCHIVE" || true)

    # Build a quick lookup set for valid_names (bash associative array)
    declare -A present=()
    for n in "${valid_names[@]}"; do present["$n"]=1; done

    local removed_any=0
    for old in "${db_names[@]}"; do
      if [[ -z "${present[$old]+x}" ]]; then
        warn "Removing stale DB entry: $old (package file missing)"
        repo-remove "$DB_ARCHIVE" "$old" >/dev/null || die "repo-remove failed for $old"
        removed_any=1
      fi
    done

    if [[ "$removed_any" == "1" ]]; then
      success "Stale entries removed from DB."
    else
      success "No stale DB entries found."
    fi
  fi

  # Rebuild/add packages
  if [[ ${#valid_pkgs[@]} -gt 0 ]]; then
    info "ðŸ“¦ Updating repository database: $DB_ARCHIVE"
    repo-add "$DB_ARCHIVE" "${valid_pkgs[@]}" || die "Failed to run repo-add."
    success "Repository database updated successfully."
  else
    warn "Skipping repo-add (no packages)."
  fi

  # Ensure pacman can fetch: repo.db and repo.files (bare names)
  ensure_pacman_bare_names

  # Optional: publish to a directory (recommended for GitLab Pages via CI artifacts)
  if [[ -n "$PUBLISH_DIR" ]]; then
    publish_to_dir "$PUBLISH_DIR"
  fi

  # Git commit/push (only if changes)
  # Include DB/files + packages + publish dir (if used)
  local paths_to_check=("${REPO_NAME}.db"* "${REPO_NAME}.files"* )
  [[ -n "$PUBLISH_DIR" ]] && paths_to_check+=("$PUBLISH_DIR")

  if ! git diff --quiet -- "${paths_to_check[@]}" 2>/dev/null || [[ ${#valid_pkgs[@]} -gt 0 ]]; then
    info "ðŸ’¾ Committing changes to git..."

    git add "${REPO_NAME}.db"* "${REPO_NAME}.files"* 2>/dev/null || true
    if [[ ${#valid_pkgs[@]} -gt 0 ]]; then git add "${valid_pkgs[@]}" 2>/dev/null || true; fi
    if [[ -n "$PUBLISH_DIR" ]]; then git add "$PUBLISH_DIR" 2>/dev/null || true; fi

    local commit_msg="${1:-Update ${REPO_NAME} repo}"
    if git commit -m "$commit_msg"; then
      success "Committed: $commit_msg"
    else
      warn "Commit skipped (no changes)."
    fi

    if git remote get-url origin >/dev/null 2>&1; then
      local current_branch
      current_branch="$(git branch --show-current)"
      git push origin "$current_branch" && success "Pushed to remote ($current_branch)." || warn "Push failed."
    else
      warn "No remote configured."
    fi
  else
    success "No changes to commit."
  fi

  print_msg "\nðŸ“Š Summary" "$CYAN"
  print_msg "Repo:        $REPO_NAME"
  print_msg "DB archive:  $DB_ARCHIVE"
  print_msg "DB bare:     $DB_BARE"
  print_msg "FILES arch:  $FILES_ARCHIVE"
  print_msg "FILES bare:  $FILES_BARE"
  print_msg "Pkgs:        ${#valid_pkgs[@]}"
  if [[ -n "$PUBLISH_DIR" ]]; then
    print_msg "Published:   $PUBLISH_DIR/"
  fi
  success "Done!"

  print_msg "\nðŸ§  Note about your 403 error" "$CYAN"
  print_msg "If pacman still gets 403 from GitLab Pages, it usually means Pages isn't publishing these files."
  print_msg "Make sure your GitLab CI publishes the '$PUBLISH_DIR/' directory (commonly 'public/')."
}

trap 'print_msg "\nðŸ›‘ Script interrupted." "$RED"; exit 1' INT TERM
main "$@"
