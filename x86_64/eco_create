#!/usr/bin/env bash

# Intelligent script for managing repository updates and git operations
# Author: System Administrator
# Version: 1.3

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Function to print colored messages
print_message() {
    echo -e "${2}${1}${NC}"
}

# Function to check if previous command succeeded
check_status() {
    if [ $? -eq 0 ]; then
        print_message "âœ“ Success: $1" "$GREEN"
        return 0
    else
        print_message "âœ— Error: $1" "$RED"
        return 1
    fi
}

# Function to check if we're in a git repository
check_git_repo() {
    # Check if git is installed
    if ! command -v git &> /dev/null; then
        print_message "Error: git is not installed!" "$RED"
        exit 1
    fi
    
    # Check if we're in a git repository (checking parent directories too)
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_message "Error: Not in a git repository!" "$RED"
        print_message "Current directory: $(pwd)" "$YELLOW"
        
        # Check if .git exists in parent directories
        CURRENT_DIR=$(pwd)
        FOUND_GIT=false
        
        while [[ "$CURRENT_DIR" != "/" ]]; do
            if [[ -d "$CURRENT_DIR/.git" ]]; then
                print_message "Found git repository in: $CURRENT_DIR" "$YELLOW"
                read -p "Change to that directory? (y/N): " -n 1 -r
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    cd "$CURRENT_DIR"
                    print_message "Changed to: $(pwd)" "$GREEN"
                    FOUND_GIT=true
                    break
                else
                    exit 1
                fi
            fi
            CURRENT_DIR=$(dirname "$CURRENT_DIR")
        done
        
        if [ "$FOUND_GIT" = false ]; then
            # Ask to initialize git repository
            print_message "\nNo git repository found." "$YELLOW"
            read -p "Initialize a new git repository here? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                git init
                check_status "Git repository initialized"
                
                # Ask to set up remote
                read -p "Set up a remote repository? (y/N): " -n 1 -r
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    echo -e "${BLUE}Enter remote URL (e.g., https://github.com/user/repo.git):${NC}"
                    read -r REMOTE_URL
                    if [ -n "$REMOTE_URL" ]; then
                        git remote add origin "$REMOTE_URL"
                        check_status "Remote added"
                    fi
                fi
            else
                exit 1
            fi
        fi
    fi
}

# Function to check for required files and directories
check_prerequisites() {
    print_message "Checking prerequisites..." "$BLUE"
    
    # Check if we're in a git repository
    check_git_repo
    
    # Show current directory contents
    print_message "\nCurrent directory contents:" "$CYAN"
    ls -la | head -20
    
    # Check for any files to process
    if ! ls ./* 2>/dev/null | grep -q .; then
        print_message "Warning: No files found in current directory" "$YELLOW"
        read -p "Continue anyway? (y/N): " -n 1 -r
        echo
        [[ $REPLY =~ ^[Yy]$ ]] || exit 1
    fi
    
    # Check if sudo is available
    if ! command -v sudo &> /dev/null; then
        print_message "Warning: sudo not found. Trying without..." "$YELLOW"
    fi
}

# Function to show what will be deleted
show_files_to_delete() {
    print_message "\nFiles that will be deleted (*.db):" "$YELLOW"
    
    # Find .db files
    DB_FILES=$(find . -maxdepth 1 -name "*.db" -type f 2>/dev/null || true)
    
    if [ -n "$DB_FILES" ]; then
        echo "$DB_FILES" | while read -r file; do
            size=$(du -h "$file" 2>/dev/null | cut -f1 || echo "unknown")
            print_message "  $file ($size)" "$RED"
        done
        
        DB_COUNT=$(echo "$DB_FILES" | wc -l)
        print_message "\nTotal .db files to remove: $DB_COUNT" "$YELLOW"
    else
        print_message "  No .db files found." "$GREEN"
    fi
    
    # Also show .db.tar.gz files that will be created/replaced
    print_message "\nRepository files that will be created:" "$CYAN"
    print_message "  ./eco_repo.db.tar.gz" "$CYAN"
    print_message "  ./eco_repo.db" "$CYAN"
    print_message "  ./eco_repo.files.tar.gz" "$CYAN"
    print_message "  ./eco_repo.files" "$CYAN"
}

# Function to get commit message
get_commit_message() {
    if [ -n "${1:-}" ]; then
        COMMIT_MSG="$1"
    else
        # Show git status to help user decide
        print_message "\nCurrent git status:" "$BLUE"
        git status --short
        
        # Check if there are changes to commit
        if git diff-index --quiet HEAD -- 2>/dev/null; then
            print_message "No changes to commit" "$YELLOW"
            
            # Still ask if they want to proceed (maybe just pushing)
            read -p "Proceed with just repo-add and push? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                COMMIT_MSG="Repository database update"
            else
                COMMIT_MSG=""
                return
            fi
        else
            echo -e "\n${BLUE}Enter commit message (Ctrl+D to cancel):${NC}"
            echo -e "${YELLOW}Tip: Use descriptive messages like 'Update packages' or 'Add new package xyz'${NC}"
            read -r COMMIT_MSG
            
            if [ -z "$COMMIT_MSG" ]; then
                COMMIT_MSG="Repository update $(date '+%Y-%m-%d %H:%M:%S')"
                print_message "Using default message: $COMMIT_MSG" "$YELLOW"
            fi
        fi
    fi
}

# Function to update repository database with the new command
update_repo_db() {
    print_message "\nStep 1: Cleaning old database files..." "$BLUE"
    
    # Show what will be deleted
    show_files_to_delete
    
    # Ask for confirmation
    read -p "Proceed with removing *.db files? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_message "Skipping database cleanup." "$YELLOW"
        return 0
    fi
    
    # Check if repo-add command exists (for Arch Linux repositories)
    if ! command -v repo-add &> /dev/null; then
        print_message "Warning: repo-add not found. Skipping repository update." "$YELLOW"
        return 0
    fi
    
    # Remove existing .db files
    print_message "Removing *.db files..." "$PURPLE"
    
    # Count files before removal
    DB_COUNT_BEFORE=$(find . -maxdepth 1 -name "*.db" -type f 2>/dev/null | wc -l)
    
    if [ "$DB_COUNT_BEFORE" -gt 0 ]; then
        if command -v sudo &> /dev/null; then
            sudo rm -rf *.db
        else
            rm -rf *.db
        fi
        
        # Count files after removal
        DB_COUNT_AFTER=$(find . -maxdepth 1 -name "*.db" -type f 2>/dev/null | wc -l)
        
        if [ "$DB_COUNT_AFTER" -eq 0 ]; then
            print_message "âœ“ Successfully removed $DB_COUNT_BEFORE .db file(s)" "$GREEN"
        else
            print_message "Warning: Some .db files could not be removed" "$YELLOW"
        fi
    else
        print_message "No .db files to remove" "$YELLOW"
    fi
    
    print_message "\nStep 2: Updating repository database..." "$BLUE"
    
    # Find files to add (excluding the script itself and certain patterns)
    FILES_TO_ADD=()
    for file in ./*; do
        if [[ -f "$file" ]]; then
            filename=$(basename "$file")
            # Skip certain files
            if [[ "$filename" == "eco_repo.db.tar.gz" ]] || \
               [[ "$filename" == "eco_repo.files.tar.gz" ]] || \
               [[ "$filename" == "eco_repo.db" ]] || \
               [[ "$filename" == "eco_repo.files" ]] || \
               [[ "$filename" == *.sh ]] || \
               [[ "$filename" == "README"* ]] || \
               [[ "$filename" == "LICENSE"* ]]; then
                print_message "Skipping: $filename" "$CYAN"
                continue
            fi
            FILES_TO_ADD+=("$file")
        fi
    done
    
    if [ ${#FILES_TO_ADD[@]} -eq 0 ]; then
        print_message "No files to add to repository" "$YELLOW"
        return 0
    fi
    
    print_message "Adding ${#FILES_TO_ADD[@]} file(s) to repository..." "$CYAN"
    
    # Run repo-add with all files
    if command -v sudo &> /dev/null; then
        sudo repo-add ./eco_repo.db.tar.gz ./*
    else
        repo-add ./eco_repo.db.tar.gz ./*
    fi
    
    check_status "Repository database updated"
    
    # Show created repository files
    print_message "\nCreated repository files:" "$GREEN"
    for repo_file in eco_repo.db.tar.gz eco_repo.db eco_repo.files.tar.gz eco_repo.files; do
        if [ -f "$repo_file" ]; then
            size=$(du -h "$repo_file" 2>/dev/null | cut -f1 || echo "unknown")
            print_message "  $repo_file ($size)" "$GREEN"
        fi
    done
}

# Function to perform git operations
perform_git_operations() {
    local commit_msg="${1:-}"
    
    # Only proceed if we have a commit message
    if [ -z "$commit_msg" ]; then
        print_message "No commit message provided, skipping git operations." "$YELLOW"
        return 0
    fi
    
    print_message "\nStep 3: Adding files to git..." "$BLUE"
    git add .
    check_status "Files added to git" || return 1
    
    print_message "\nStep 4: Committing changes..." "$BLUE"
    git commit -m "$commit_msg"
    check_status "Changes committed" || return 1
    
    print_message "\nStep 5: Pushing to remote repository..." "$BLUE"
    
    # Check if we have a remote
    if ! git remote | grep -q .; then
        print_message "No git remote configured. Would you like to set one up?" "$YELLOW"
        read -p "Set up remote? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo -e "${BLUE}Enter remote URL:${NC}"
            read -r REMOTE_URL
            if [ -n "$REMOTE_URL" ]; then
                git remote add origin "$REMOTE_URL"
                check_status "Remote added"
            else
                print_message "No URL provided. Skipping push." "$YELLOW"
                return 0
            fi
        else
            print_message "Skipping push (no remote configured)." "$YELLOW"
            return 0
        fi
    fi
    
    # Get current branch
    CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
    
    # Push with retry logic
    MAX_RETRIES=3
    RETRY_COUNT=0
    
    while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
        print_message "Pushing to origin/$CURRENT_BRANCH..." "$BLUE"
        if git push origin "$CURRENT_BRANCH"; then
            print_message "âœ“ Successfully pushed to $CURRENT_BRANCH" "$GREEN"
            return 0
        else
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                print_message "Push failed. Retry $RETRY_COUNT of $MAX_RETRIES..." "$YELLOW"
                sleep 2
            else
                print_message "Push failed after $MAX_RETRIES attempts" "$RED"
                print_message "You can try manually: git push origin $CURRENT_BRANCH" "$YELLOW"
                return 1
            fi
        fi
    done
}

# Function to show summary
show_summary() {
    print_message "\nðŸ“Š Operation Summary" "$BLUE"
    print_message "===================" "$BLUE"
    
    # Show current directory
    print_message "\nWorking directory: $(pwd)" "$CYAN"
    
    # Show repository files
    print_message "\nRepository files:" "$GREEN"
    for repo_file in eco_repo.db.tar.gz eco_repo.db eco_repo.files.tar.gz eco_repo.files; do
        if [ -f "$repo_file" ]; then
            size=$(du -h "$repo_file" 2>/dev/null | cut -f1 || echo "unknown")
            print_message "  $repo_file ($size)" "$GREEN"
        fi
    done
    
    # Show last commit
    print_message "\nLast commit:" "$BLUE"
    git log -1 --oneline 2>/dev/null || print_message "No commits yet" "$YELLOW"
    
    # Show remote if available
    REMOTE_URL=$(git remote get-url origin 2>/dev/null)
    if [ -n "$REMOTE_URL" ]; then
        print_message "\nRemote repository: $REMOTE_URL" "$BLUE"
    else
        print_message "\nNo remote repository configured" "$YELLOW"
    fi
    
    # Show git branch
    BRANCH=$(git branch --show-current 2>/dev/null || echo "unknown")
    print_message "Current branch: $BRANCH" "$BLUE"
}

# Show help function
show_help() {
    echo "Usage: $0 [commit_message]"
    echo "       $0 --help"
    echo ""
    echo "Description:"
    echo "  This script updates the repository database and pushes changes to git."
    echo "  It performs:"
    echo "  1. Removes all *.db files (sudo rm -rf *.db)"
    echo "  2. Updates repository database (sudo repo-add ./eco_repo.db.tar.gz *)"
    echo "  3. Git add, commit, and push"
    echo ""
    echo "Features:"
    echo "  â€¢ Safely removes *.db files with confirmation"
    echo "  â€¢ Automatically finds git repository in parent directories"
    echo "  â€¢ Can initialize git repository if needed"
    echo "  â€¢ Shows what files will be deleted/created"
    echo "  â€¢ Retries git push on failure"
    echo ""
    echo "Examples:"
    echo "  $0 \"Updated repository with new packages\""
    echo "  $0  # Interactive mode"
    exit 0
}

# Main function
main() {
    local commit_msg=""
    
    # Parse command line arguments
    if [ $# -ge 1 ]; then
        case "$1" in
            --help|-h)
                show_help
                ;;
            *)
                commit_msg="$1"
                ;;
        esac
    fi
    
    print_message "ðŸš€ Starting repository update process..." "$BLUE"
    print_message "========================================" "$BLUE"
    print_message "Command sequence:" "$CYAN"
    print_message "1. sudo rm -rf *.db" "$CYAN"
    print_message "2. sudo repo-add ./eco_repo.db.tar.gz *" "$CYAN"
    print_message "3. git add ." "$CYAN"
    print_message "4. git commit -m \"message\"" "$CYAN"
    print_message "5. git push" "$CYAN"
    print_message "========================================" "$BLUE"
    
    # Check prerequisites
    check_prerequisites
    
    # Get commit message
    get_commit_message "$commit_msg"
    
    # Update repository database
    update_repo_db
    
    # Perform git operations
    if [ -n "${COMMIT_MSG:-}" ]; then
        perform_git_operations "${COMMIT_MSG:-}"
    fi
    
    # Show summary
    show_summary
    
    print_message "\nâœ… Process completed!" "$GREEN"
}

# Error handling - more lenient
set -e
trap 'print_message "Script interrupted by user" "$RED"; exit 1' INT

# Run main function with all arguments
main "$@"